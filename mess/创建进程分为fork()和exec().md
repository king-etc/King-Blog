作者：北极
[链接](https://www.zhihu.com/question/66902460/answer/1642544378)
# 为什么Linux下要把创建进程分为fork()和exec()(一系列函数)两个函数来处理?
*一堆人在那个说什么Linux设计哲学，最小、完整之类的，我只想说两个字：扯淡。有一个回答是对的 @王杰聪 Linux里的很多东西是学UNIX的，UNIX里，fork和exec这两个API刚设计出来的时候，连现代操作系统里的进程、线程概念都没有，什么最小且完整，连进程都没有，谈什么最小且完整？*
fork、exec在UNIX里的最初的目的是：shell要执行别的东西，干完活再返回给shell，但当年（应该是1960~1970年代）是没有进程的概念的，exec就是把老的shell给干掉，然后去干活，干完活再返回回来。注意，当年是没有进程的概念的，exec就是直接把shell从内存里拿掉。但这样做有一些坏处，就是每次要重新加载shell，于是fork就出现了，让新任务执行（复制一份），shell不动（具体是交换到磁盘上还是怎么操作不太了解），新任务干完活，shell继续跑。因为当年没有多任务的概念，fork相当于提供了一个虚假的多任务环境。
我觉得真没必要鼓吹fork有多好，fork诞生的环境，是没有多任务概念的情况下，解决多任务的需求的，所以它的功能看上去很奇怪，因为不是解决今天的多任务场景的。所谓的最小且完整，这都是后人硬加上去的解释，最初根本没这么多考虑，而且fork和exec诞生于不同的时代。
如今硬件软件都已经发展的足够好了，用CreateProcess没什么不好，哪怕pthread也比fork要先进的多。也正如 @陈硕  说的：fork对多任务其实不友好。
自己写一个操作系统，手工实现一个fork，就知道fork有多坑了，fork对寄存器使用很敏感，任何一个非标准的ABI访问都可能导致fork崩溃，当然高级语言开发者不需要考虑这个问题，因为高级语言的ABI都是完全符合规范的。在Linux，fork并非一个真正的系统调用，我印象里它走的是clone或者vfork写完才发现，这个是一个老问题。
[参考资料](https://en.wikipedia.org/wiki/Fork_(system_call)
补充一些：fork被设计出来以后，UNIX开发者发现这个东西很好用，所以就一直保留下来，一直到今天，被Linux延续下来，但不代表说fork/exec的机制有多先进，不然后人也没必要搞pthread这套库了。有人用，并且用的人还挺多，只是因为它太古老了，支持的操作系统多。作为对比，这个东西就像printf一样，古老，但不一定多好用，比它们强大的API多的是，只不过兼容性不好，行为不好控制而已。
